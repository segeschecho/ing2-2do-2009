\chapter{Diseño}


\section{Ideas llevadas a cabo}

En éste capítulo se llevará a cabo el diseño especificado para los User Stories asociados al sprint tales que, si bien no necesitaban ser implementados, requerían de un diseño.

Estos user stories son aquellos referidos a la evaluación de modelos utilizando diferentes algoritmos, de manera distribuida y a la fácil configuración entre las subpartes de un determinado modelo.

Para ello lo que se intentó llevar a cabo es la posibilidad de procesar un determinado modelo, siguiendo las reglas de descomposición asociadas a un determinado algoritmo. 

En la imagen que se puede ver a continuación se refleja lo pensado por el grupo para lidiar con el requerimiento solicitado apra ésta parte del trabajo práctico.

Comencemos a describir entonces ésta idea.

Existirán, a diferencia del trabajo práctico anterior algunas fuentes de datos más, no sólo los datos sensados desde las terminales remotas asignadas a la ECP sino los provenientes de otras ECP relevantes. Todos estos datos de manera combinada
van a ser datos ''crudos" a procesar. Por otro lado vamos a tener también resultados parciales o totales provenientes de otras ECP los cuales serán utilizados en el procesamiento. Hasta aquí todo lo referido al imput de procesamiento.

Por otro lado tendremos un modelo, un conjunto de reglas a aplicar para los datos, siguiendo la línea del trabajo práctico anterior, la idea es que éstas reglas se refieran a variables o parámetros de algún tipo de almacenamiento de los datos, como pueden ser paquetes, diccionarios, etc, con la idea de no intervenir en la propia regla pasandole los datos que propiamente necesita.


La idea es que el tipo de procesamiento va a depender prácticamente del algoritmo encargado de procesarlo. Es decir, dado un determinado modelo y un conjunto de datos, el algoritmo será capaz de dividir las reglas en subpartes a su criterio, e intentará correrlas en tantos procesadores como le convenga para agilizar el procesamiento. Por otro lado, una vez obtenidos los resultados, acturará acordemente a lo que se solicite(Ej, pasarlo a otra componente, almacenarlo en una BD, etc).

Como se verá en la descripción detallada del diseño, itentaremos que el intercambio entre algoritmos se haga de manera sencilla y que además la ejecución concurrente, se pueda llevar a cabo de forma transparente al algoritmo. Con ésto último no contradecimos la idea de es el algoritmo quien determina las subpartes y cómo se ejecutarán, sino que intentaremos utilizar alguna clase adicional que se encargue de brindar fuentes de procesamiento cuando se lo requiera.

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{../Disenio.png}
\end{figure}

\clearpage
\newpage


\section{Diagrama de clases}

En ésta sección describiremos como llevamos a un diagrama de clases las ideas mencionadas con anterioridad de modo tal de lograr una buena trazabilidad entre lo que pensamos y lo que vamos a llevar a cabo.


El diagrama correspondiente a dicha sección se puede observar al final de la misma. Cabe destacar que se utilizó para las funciones una notación similar a lenguages tipo C, C++, .Net o Java pero que su equivalente a Smalltalk o similires se puede realizar de manera sencilla, sólo que la herramienta que utilizamos no lo permitía. 


Pasemos entonces a enumerar las diferentes clases y las funcionalidades asociadas:

\begin{enumerate}

\item \textbf{Ejecutador Modelos: }Esta clase se va a encargar del manejo del procesamiento de los datos. Invocará a otras clases para llevar a cabo cada uno de los pasos. 
	\begin{itemize}
  \item \textbf{ejecutarModelo: }Esta función es la que en un determinado momento se utiliza para ejecutar un modelo. Cabe destacar que seguimos con la trazabilidad del trabajo práctico anterior en cuanto que al pasarse el modelo a procesar, el mismo puede intercambiarse por otro, ademas se le pasa 3 parámetros más correspondientes a armadores y bases de datos, que serán comentadas a continuación. 
  \end{itemize}

\item \textbf{BDP Access: }Esta clase se encarga de la comunicación con la base de datos, de los datos a procesar en un determinado momento, ya sea los datos propios o los de otras Tr's.
	\begin{itemize}
  \item \textbf{datos : }Esta función o mensaje retorna dado un tiempo los datos asociados correspondientes.
  \end{itemize}

\item \textbf{BDRP Access: }Esta clase se encarga de la comunicación con la base de datos de los resultados parciales almacenados hasta el momento proveniente de otras ECP.
	\begin{itemize}
  \item \textbf{datos: }Dado un tiempo devuelve los datos correspondientes.
  \end{itemize}

\item \textbf{Armador Paquete: }Esta clase arma de alguna forma, una estructura o paquete con todos los datos necesarios para el procesamiento.
	\begin{itemize}
  \item \textbf{armar: }Dados datos a procesar y resultados parciales, arma una estructura correspondiente para procesar, en principio podría ser un diccionario.
  \end{itemize}

\item \textbf{Conjunto Reglas: }Esta clase si bien no era necesaria modelarla, muchas veces en Ingeniería I nos solicitaban que aparezca para poder mostrar ciertas características deseables.
	\begin{itemize}
  \item \textbf{Iterador: }Como toda estructura de almacenamiento, puede proveer un iterador para recorrerla.
  \end{itemize}
  
\item \textbf{Regla: }Esta clase se corresponde con una determinada regla.
	\begin{itemize}
  \item \textbf{Ejecutar : }La idea es que dado un paquete de datos, la regla se ejecute, utilizando los datos de dicho paquete.
  \end{itemize}

\item \textbf{Estrategia: }Esta clase o bien es abstracta o bien es una interfaz, la idea es que un Ejecutador de modelos tenga una estrategia o algoritmo asociado para procesar el modelo. Este patrón(Estrategy), es el que permite fácilmente intercambiar el algoritmo de evaluación de reglas.
	\begin{itemize}
  \item \textbf{aplicar: }Dados un conjunto de reglas y un paquete de datos tratará de ejecutar las reglas utilizando esos datos.
  \end{itemize}
  
\item \textbf{Algoritmo 1: }Esta clase implementa una estrategia, la idea es que implemente la función aplicar de la manera que le convenga.
	\begin{itemize}
  \item \textbf{join: }En este caso utiliza una funcion join para juntar los resultados de procesamientos intermedios, podría utilizar otra función de acuerdo al algoritmo.
  \item \textbf{hacerAlgoUtil : }Corresponde a posibles funciones adicionales que implemente.
  \end{itemize}
    
\item \textbf{Fabrica Calculadores: } Se trata del patrón Factory, la idea es fabricar calculadores cuando el algoritmo lo solicite para procesar un subconjunto de reglas. El calculador en principio podría ejecutarse en otro procesador, o bien ser un proceso independiente en un procesador.
	\begin{itemize}
  \item \textbf{calculador: }Devuelve un calculador.
  \item \textbf{stop: }Destruye una instancia de calculador cuando ya no es requerida.
  \end{itemize}
  
\item \textbf{Calculador: }Esta clase representa a los calculadores encargados de ejecutar las reglas.
	\begin{itemize}
  \item \textbf{calcular : }Dados datos y un conjunto de reglas las ejecutará.
  \end{itemize}
\end{enumerate}


\begin{figure}[h]
\centering
\includegraphics[scale=0.7]{../Disenio(2).png}
\end{figure}

\clearpage
\newpage


\section{Diagrama de objetos y secuencias}

Para ésta sección llevaremos a cabo una instancia del problema a modo de mostrar el funcionamiento esperado descripto anteriormente. 

Para ello realicezaremos un diagrama de objetos y un escenario correspondiente al mismo respresentado por varios diagramas de secuencias.

La idea es simple vamos a tener instancias de los principales clases que intervienen en el procesamiento y surgirán algunos objetos más, propios de los escenarios elegidos.

Nuevamente los diagramas correspondientes se pueden observar al final de ésta sección para poder ir observando los mismos a medida que se lee el informe.

Comencemos con los objetos, vamos a tener instancias de los accesos a la base de datos, del ejecutor, del armador, del algoritmo, de las reglas y de la fábrica. Como resultado del escenario se podrán notar la aparicion de intancias de calculadores, y subconjuntos de reglas con reglas asociadas. Esto es para que se pueda apreciar mejor el diagrama de secuencias.

Sigamos entonces explicando un poco el funcionamiento de los diagramas de secuencias elegidos. Vamos a contar básicamente el procedimiento ya que la comunicación propiamente dicha es fácilmente observable en los diagramas. La idea es que el eljecutor de modelos tomará un modelo(conjunto de reglas), las bases de datos , y el armador. A su vez como se mencionó anteriormente el ejecutor tiene una estrategia asociada, en este caso el algoritmo 1. Entonces el ejecutor solicitará los datos correspondientes a los accesos a las bases de datos para un determinado tiempo. Una vez hecho ésto solicitará al armador que le provea un paquete con todos los datos necesarios para el procesamiento.

Cuando los datos ya están homogeineizados se delega la tarea de ejecución al algoritmo o estrategia. El algoritmo va a dividir las reglas en subpartes de acuerdo a su conveniencia o su manera de operar, en este caso en 2 partes, y para ejecutar concurrentemente estas partes solicitará a la fabrica dos calculadores. A cada uno de los calculadores le solicitará que ejecute el correspondiente subconjunto de reglas, y una vez obtenidos los datos, los unificará para devolver un resultado final.

Es importante destacar que cuando un calculador finalice su ejecución, el algoritmo le solicitará a la fabrica que elimine o detenga el funcionamiento de dicho calculador ya que no es más necesario. La fábrica destruirá éste calculador, y liberará su relación con un determinado procesador para que pueda ser utilizado nuevamente cuando sea solicitado.

Finalmente el calculador ejecutará cada una de las reglas solicitadas y luego devolverá el resultado de dicha ejecución.


\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{../Disenio(3).png}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[scale=0.55]{../secuencias.png}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{../aplicarReglas.png}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[scale=0.7]{../creaYDestruyeCalc.png}
\end{figure}

\clearpage
\newpage